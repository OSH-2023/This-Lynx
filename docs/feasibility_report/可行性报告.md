# 可行性报告
## 理论依据
1. 基于JNI使用Scala和rust进行交互
Scala是在JVM上运行的语言，和Java比较相似。与其他语言交互时，主要有JNI(Java Native Interface), JNA(Java Native Access), OpenJDK project Panama三种方式。其中最常用的即为JNI接口。
Rust则通过二进制接口的方式与其他语言进行交互，调用包含其它函数接口的二进制库，或生成二进制库供其他语言使用。
在我们的项目中，由于希望保留scala的外部接口，所以选择scala为client语言，用Rust改进spark的一些功能，并将实现的接口提供给scala语言下的spark框架使用。

2. 基于vega的实现
Spark编译
RPC的一种实现:capnp
vega
## 技术依据
### JNI交互
Scala可以与Java代码无缝衔接，而Java可以与C通过JNI来交互，所以可以通过Rust的extern语法，按照C的方式调用JNI，并完成Scala和Rust的各类交互。
然而，正如我们通常不会直接在Rust中通过二进制接口调用C的标准库函数，而是使用libc crate一样，直接使用JNI对C的接口会使得编程较为繁琐且不够安全，代码中的大量unsafe块使得程序稳定性大大下降，所以，我们选择对JNI进行了安全的封装的接口：**jni[^1] crate**。
#### Rust调用Scala
**数据交互**
两种语言在进行交互时，必须使用两边共有的数据类型。
对于基础的参数类型，可以直接用`jni::sys::*`模块提供的系列类型来声明，对照表如下：
|Scala 类型  |Native 类型 |类型描述|
|---|---|---|
|boolean    |jboolean	|unsigned 8 bits|
|byte	    |jbyte	    |signed 8 bits|
|char	    |jchar	    |unsigned 16 bits|
|short	    |jshort	    |signed 16 bits|
|int	    |jint	    |signed 32 bits|
|long	    |jlong	    |signed 64 bits|
|float	    |jfloat	    |32 bits|
|double	    |jdouble	|64 bits|
|void	    |void	    |not applicable|
对于复合类型，如对象等，则可以统一用`jni::objects::JObject`类型声明。该类型封装了由JVM返回的对象指针，并为该指针赋予了生命周期，以保证在Rust代码中的安全性。
**方法交互**
由于语言间对对象及其特性的实现不同，很难直接调用对方语言中的函数或方法。于是通常需要使用server-client模型，将执行函数或方法的任务交给sever语言，即：client传递所需的数据参数，并由server执行计算任务，并将最终结果返回给client。
基于这种模型的设计，jni提供了调用scala中函数、对象方法以及获取对象数据域的方法。它们定义于`jni::JNIEnv`中，如接受对象、方法名和方法的签名与参数的`jni::JNIEnv::call_method`，接受对象、成员名、类型的`jni::JNIEnv::get_field`等
此外，jni额外实现了一个`jni::objects::JString`接口，用以方便地实现字符串的传输。
#### Scala调用Rust
Rust可以通过`pub unsafe extern "C" fn{}`来创建导出函数，或通过jni封装的函数`JNIEnv::register_native_methods`动态注册native方法。
导出函数会通过函数名为Scala的对应类提供一个native的静态方法。
动态注册会在JNI_Onload这个导出函数里执行，jvm加载jni动态库时会执行这个函数，从而加载注册的函数。
在Rust中定义这些函数时，同样需要遵循上面的那些交互方法和规范。
### Cap'n Proto
Cap'n Proto是一种速度极快的数据交换格式，以及能力强大的
### 优化RDD依赖关系/调度
## 创新点
## 概要设计报告
## 进度管理

[^1]:https://capnproto.org/