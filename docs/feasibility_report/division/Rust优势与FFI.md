出于工作量和可行性考虑，我们不准备使用 Rust 完全重写 Spark ，而是准备选取 Spark 的性能瓶颈且Rust可以为之带来较大优化的部分，使用Rust改写，以达到优化Spark性能的目的。
为此，我们需要考虑Rust在哪些方面比Scala（Spark所使用的语言）有较大的优势，并在这些方面，寻找可能的切入点。
## Rust在Spark背景下相较于Scala的优势
### 安全性
scala 所有的对象都是在堆中的，有 Head 的，生命周期由 GC 管控的。虽然有不用关心分配、释放的自由。却也导致了 STW 和更大的内存占用。
Rust 通过静态内存安全管理和所有权系统，可以避免许多 Spark 运行时错误，例如内存泄漏、垂悬指针异常等。而与Scala相比，Rust的内存管理发生在编译期，其所有权和声明周期的计算与检查都在编译期执行，这使得它无需消耗较大性能的GC机制，就能保证内存安全。
此外，Rust将运行时错误划分为两类，通过模式匹配的控制方式，在面对可恢复的错误时执行对应的错误处理代码，而面对不可恢复的错误时发生panic停止程序，既进一步保证了安全，又提高了用户的体验。
在Spark的内存密集阶段，可以使用Rust改写，以减少内存占用、提高程序性能。
### 高性能
Rust 秉承零成本抽象原则，通过无运行时开销的特性，将许多其他语言的运行时开销（如GC）放置到了编译期，并将顶层的代码编译为较为高效的机器码，使得程序员在进行抽象时，不必担心性能的下降。
使用 Rust 进行 Spark 的性能瓶颈优化可以提高数据处理速度和效率，减少资源浪费和计算成本。
### 并发性
Spark 是一个分布式计算框架，具有良好的并发性能。而 Rust 则通过所有权和类型系统，将许多并发错误转化为了编译时错误，从而避免在部署到生产环境后修复代码或出现竞争、死锁或其他难以复现和修复的 bug ，实现了高效而安全的并发设计。
安全高效的并行与函数式编程息息相关。Scala正是由于其函数式编程的特性被Spark选中，而同样作为函数式的语言，Rust对并行的支持更好。使用 Rust 对 Spark 的高并发场景进行优化，可以进一步提高 Spark 的并发性能和安全性，从而提高整个应用程序的性能。
### 编程实践
为了深入体会Rust的编程风格和相较于其他语言的优势，笔者选用Rust语言来实现OS Lab2 的编写Shell的项目，对Rust的优点和风格有了一定感触。
Rust为了获取安全性和高性能，对程序员施加了较多的规则，在编译期进行了较为严格的检查（内存安全正），使得编程难度显著提高。但是如果熟悉了它的编程风格，就可以轻松写出安全而高效的代码。此外，用Rust编写的代码，只要能够通过编译，基本就可以正常运行，且在调试代码时，可以分模块测试而不用担心它们的互相影响————这提高了调试代码的效率，而且适于多人协作开发（在函数式编程方式下尤是如此）。
项目地址：https://github.com/XhyDds/osh-2023-labs/tree/master/lab2

## Rust与Scala的交互
除了考虑Rust的优势以外，因为我们只对Spark的部分组件重写，所以还需要考虑Rust与Scala的交互问题。
### 主体语言的选取： Rust 或 Scala
由于Spark已经有了丰富的生态，出于兼容生态的考虑，我们选择将Rust改写的部分作为内部接口，而将Scala作为主体语言，调用Rust代码提供的接口，适当修改Spark的内部实现，而保留其外部接口不变，以兼容其生态，让用户可以在不改变Spark使用方式的前提下而获得更好的性能和安全保证。
### FFI
Rust 不支持源代码级别直接与其他语言的交互， 也就是说不支持直接在Rust code 中直接内嵌其他编程语言代码，而只支持以二进制库的方式来互相调用，所以语言界限清晰明确，避免了许多问题。
总的来说，Rust可以与C较为方便地交互，从而可以与C交互的语言，大多都能与Rust进行交互。Scala作为JVM上的语言，与Java相近，而Java与C可以通过JNI协议进行交互（会丢失JVM的跨平台性）。所以，我们这里也遵循从C到Java到Scala的顺序，逐步实现Rust与Scala的交互。
#### Rust<->C
**Rust->C**

**Rust<-C**

#### Rust<->Scala

#### 静态库与动态库的选取
静态库：
1. 静态库对函数库的链接在编译时期完成。
2. 程序在运行时与函数库无关，方便移植。
3. 浪费空间和资源，因为所有相关的目标文件与牵涉到的函数库被链接合成一个可执行文件。
动态库：
1. 动态库把对一些库函数的链接载入推迟到程序运行的时期。
2. 可以实现进程之间的资源共享。
3. 对于用户而言，程序升级更简单。
4. 链接载入可完全由程序员在程序代码中控制。
#### 编程实例